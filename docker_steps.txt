Semana do docker
Aqui irei colocar alguns comando uteis do docker para relembrar



Passos para instalar o Ubuntu corretamente:
	Vá no Microsoft Store e instale o Ubuntu

  	Abra o Ubuntu que acabou de ser instalado

  	Insira seu usuario e senha novos

  	De um "sudo apt update" para atualizar e verificar se foi instalado corretamente



Passos para instalar Docker, seguimos com a documentação do docker
Mas vou colocar o resumo aqui
 	
	Remova pacotes que podem dar conflitos
		"for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done"

  	Instalar as dependências
		sudo apt-get update
		sudo apt-get install ca-certificates curl
		sudo install -m 0755 -d /etc/apt/keyrings
		sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
		sudo chmod a+r /etc/apt/keyrings/docker.asc
		echo \\
		"deb \[arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\
		$(. /etc/os-release \&\& echo "${UBUNTU\_CODENAME:-$VERSION\_CODENAME}") stable" | \\
		sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
		sudo apt-get update"

	Instalar os pacotes do docker
		"sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin"

  	Rode o "sudo docker run hello-world" para verificar se a instalação foi executada com sucesso, se sim ira receber algo como
		Hello from Docker!

	Criar o grupo do docker(*O grupo docker é um grupo de usuários do sistema Linux que tem permissão para executar comandos do Docker sem precisar usar sudo.*)
		"sudo groupadd docker"

	Adicione seu usuário para o grupo
 		 "sudo usermod -aG docker $USER"

  	Salve as mudanças
		"newgrp docker"
	
	Rode novamente o "docker run hello-world" para verificar se você pode rodar o docker sem o sudo



Comando para o docker iniciar ao executar o Ubuntu no windows
  	sudo systemctl enable docker.service
 	sudo systemctl enable containerd.service



Comandos úteis
  	service docker status -> Para verificar status do docker
 	service docker start -> Para iniciar o docker
	docker images -> Lista todas as imagens no repositório local
	docker rm <id> -> Remove o container do id especificado
	docker rmi <nome:tag> -> Remove a imagem do repositório local
	docker start <nome_container> -> Executa um container
	docker run <nome_container> ls -> Para listar os pacotes da imagem
	docker run --name <definir_nome> <nome_container> <nome_imagem> -> Executa um container com o nome que definimos 
	docker container prune -> Remove todos os containers
	docker rmi $(docker images -q) -> Remove todas as imagens
	docker rename <nome_antigo> <nome_novo> -> Renomeia o container
	docker exec -it <nome_container> <comando> -> Executa comando dentro do container ex: apt update(atualiza os pacotes do container)
	docker commit <nome_container_a_ser_commitado> <nome_da_nova_imagem> -> Cria uma nova imagem com os pacotes do container_a_ser_commitado
	docker build -t <novo_nome_da_imagem:versao> <caminho(normalmente .)> -> Constrói a nova imagem a partir das instruções do dockerfile
	docker pull <nome_imagem:versao> -> Baixa a imagem do dockerhub
	docker volume rm <nome_volume> -> Remove o volume se não estiver sendo utilizado por nenhum container
	docker volume create <nome_volume> -> Cria um novo volume
	docker run --rm <imagem:versao> <comando> -> Podemos rodar nossa imagem e ja excluir assim que ela para de executar
	docker network create --driver <tipo_de_rede> <nome_rede> -> Cria uma nova rede para fazer as conexões dos containers

	docker rmi $(docker images -q) -> Exclui todas as imagens de uma só vez, funciona para containers também
	docker compose up -> Instancia o docker-compose.yml 
	docker compose down -> Derruba o docker-compose.yml
	docker compose ps -> Vemos os containers que esse docker compose está rodando



Algumas flags
	Flag	Significado	Uso comum
	-d	Detached	Roda em background
	-i	Interactive	Mantém STDIN aberto
	-t	Terminal (TTY)	Permite terminal colorido/interativo
	--rm	Remove auto	Limpa após encerrar
	-v	Volume	Compartilha arquivos
	-p	Porta	Expõe serviços do container
	--name	Nome customizado	Facilita gerenciamento
	-e 	Env		Permite manipular arquivos env
	-s	Size		Permite ver o tamanho do container
	--network Rede		Define uma rede para ser utilizada no container


Comandos do EXEC
	-it <nome_container> top -> Mostra os processos ativos do container
	dpkg -l -> Lista todos os pacotes instalados do container	


Atalhos
	CTRL + C destrava o terminal caso trave
	CTRL + L limpa terminal


Dockerfile Commandos
	FROM imagem:versao -> Qual imagem e versão vamos utilizar
	RUN comandos -> Quais comandos vamos executar no terminal ex: apt update(atualiza os pacotes do container)
	WORKDIR caminho -> Caminho no qual vamos executar as instruções
	COPY caminho -> Quais arquivos e para onde vamos copiar estes
	EXPOSE porta -> Onde vamos expor nossa aplicação
	ENV nome="variável" -> Variáveis do sistema
	CMD [ "comandos" ] -> Comandos que serão executados


Subir a imagem no DockerHub
	docker login -> Para logar no dockerhub pelo terminal
	docker logout -> Para deslogar 

	Passos depois de logar:
		docker tag <imagem:versao> <nome_usuario_dockerhub/imagem:versao> -> Para criar uma imagem ja existente com o nome de usuário configurado
		docker push <nome_usuario_dockerhub/imagem:versao> -> Para subir a imagem depois de logar
		

Persistência de dados
	Primeiro, criamos nosso container
		"docker run -it -v /<caminho_para_persistir_no_container> <imagem>" (repare que nesse exemplo, criamos um novo diretório com a flag -v)
	
	Segundo, temos que verificar nosso container usando o inspect
		"docker inspect <nome container>
		e buscaremos a informação "Mounts" -> "Source", onde tem o caminho desses dados persistidos 
	
	Terceiro, para acessar esse caminho devemos entrar como um "administrador"
		"sudo su" então inserimos a senha de admin e depois apenas inserir o caminho da segunda etapa no comando "cd <caminho>"

	DICA: 
		Como criar vários arquivos de uma vez para testar a persistência 
			"touch <nome_arquivo{1..5}.tipo_do_arquivo(ex: txt)>"
	

Persistência de dados com Bind Mounts
	Primeiro, criamos nosso container
		"docker run -it -v /<nome_pasta_para_persistir>:/<caminho_para_persistir_no_container> <imagem>"

	Por fim
		Conseguimos visualizar em nosso sistema tudo que for criado em /<nome_pasta_para_persistir> de dentro do container
		e caso criarmos um novo container apontando para essa pasta, as informações persistira 


Persistência de dados com volumes
	Primeiro, criamos nosso container criando ou utilizando um volume existente
		"docker run -it -v <nome_volume>:/<caminho_para_persistir_no_container> <imagem>"
		ou
		"docker run -it --mount source=<nome_volume>,target=/<caminho_para_persistir_no_container> <imagem>"
	
	Por fim
		Podemos utilizar o "docker volume ls" para verificar os volumes ou acessando o caminho /var/lib/docker/volumes e para
		verificar o arquivo devemos entrar em _data ja dentro desse caminho dos volumes



Manipulando redes no Docker (OBS: Por padrão os containers vem como Bridge)
	docker network disconnect <nome_rede> <nome_container> -> Desconecta o container de uma rede
	docker network connect <nome_rede> <nome_container> -> Conecta o container a uma rede
	docker network inspect <nome_rede> -> Inspeciona os containers que estão conectados a rede

	Dica: Estando os dois containers estando na mesma rede, podemos conecta-los utilizando os nomes dos containers
		"ping <nome_container>"






